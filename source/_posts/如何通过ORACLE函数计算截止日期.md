---
title: 如何通过ORACLE函数计算截止日期
date: 2019-06-09 20:21:38
tags: ORACLE
categories: ORACLE
---

#  ORACLE计算一个日期加上指定工作日之后的时间

​	我们开发过程中经常需要计算截止日期，如果是简单向后数几天这种都很简单，但是一旦涉及到计算工作日(除法定节假日及周六日)，就比较麻烦了。

## 	建立一张法定节假日及调休相关情况表。

```sql
-- ----------------------------
-- Table structure for T_CONF_CALENDAR
-- ----------------------------
DROP TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR";
CREATE TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" (
  "KID_RLJLH" VARCHAR2(50 BYTE) NOT NULL ,
  "MC" VARCHAR2(100 BYTE) ,
  "DM" DATE ,
  "NF" NUMBER ,
  "YF" NUMBER ,
  "RQ" NUMBER ,
  "XQ" VARCHAR2(50 BYTE) ,
  "SFJJR" NUMBER 
)
TABLESPACE "ZWFWPT"
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."KID_RLJLH" IS '日历记录号';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."MC" IS '名称';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."DM" IS '代码';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."NF" IS '年份';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."YF" IS '月份';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."RQ" IS '日期';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."XQ" IS '星期';
COMMENT ON COLUMN "ZWFWPT_ZBBA"."T_CONF_CALENDAR"."SFJJR" IS '是否节假日 0节假日 1调休上班日';
COMMENT ON TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" IS '配置表-日历配置表';

-- ----------------------------
-- Primary Key structure for table T_CONF_CALENDAR
-- ----------------------------
ALTER TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" ADD CONSTRAINT "SYS_C0068227" PRIMARY KEY ("KID_RLJLH");

-- ----------------------------
-- Checks structure for table T_CONF_CALENDAR
-- ----------------------------
ALTER TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" ADD CONSTRAINT "SYS_C0068222" CHECK ("KID_RLJLH" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" ADD CONSTRAINT "SYS_C0068223" CHECK ("KID_RLJLH" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" ADD CONSTRAINT "SYS_C0068224" CHECK ("KID_RLJLH" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" ADD CONSTRAINT "SYS_C0068225" CHECK ("KID_RLJLH" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "ZWFWPT_ZBBA"."T_CONF_CALENDAR" ADD CONSTRAINT "SYS_C0068226" CHECK ("KID_RLJLH" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

```

​	这里我已经添加了一些节假日及调休记录，如下图所示：

![](https://raw.githubusercontent.com/cuiweii/FigureBed/master/img/%E6%97%A5%E5%8E%86%E9%85%8D%E7%BD%AE%E8%A1%A8%E6%88%AA%E5%9B%BE.png)

## 	判断一个日期是工作日的条件是什么，工作日必须同时满足以下几个条件：

​	**非法定节假日**并且**非周六周日**或者**是调休上班日**。

​	非法定节假日判断(只需要判断日期是否存在于日历配置表中并且为法定节假日)

```sql
SELECT
	SYSDATE 
FROM
DUAL 
WHERE
	SYSDATE NOT IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 0 )
```

​	非周六日判断，这里给出判断SQL，Oracle判断周六日可以参考这篇文章

[oracle判断日期不在周六周日](https://www.cnblogs.com/zhangyangtao/p/9817503.html)

```sql
SELECT
	SYSDATE 
FROM
DUAL 
WHERE
	TO_CHAR(SYSDATE,'D') NOT IN (1,7)
```

​	是调休上班日

```sql
SELECT
	SYSDATE 
FROM
DUAL 
WHERE
	SYSDATE IN （SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 1）
```

​	综合三个条件使用AND、OR连接条件后得到判断工作日SQL语句

```sql
SELECT
	DAY_ID 
FROM
	( SELECT SYSDATE DAY_ID FROM DUAL ) 
WHERE
	TO_CHAR ( DAY_ID, 'D' ) NOT IN ( 1, 7 ) 
	AND DAY_ID NOT IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 0 ) 
	OR DAY_ID IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 1 )
```

## 	通过数据库函数来实现计算工作日的功能

​	思路是自定义一个函数**FUNC_GETDEADLINE**,输入两个变量**INPUTDATE**（输入日期）和**DAY_OFFSET**（计算DAY_OFFSET个工作日后的日期），通过WHILE循环，如果判断一个日期为工作日则将工作日数量加1，直到达到DAY_OFFSET个工作日，然后跳出WHILE循环返回计算得到的工作日日期。

​	这里有一种特殊的判断，传入的DAY_OFFSET为正数时我们可以理解为计算DAY_OFFSET个工作日之后的日期，传入的DAY_OFFSET为负数时又该如何理解呢？既然为正数是向后推算，那么为负数则可理解为计算DAY_OFFSET个工作日之前的日期，所以函数中多了一个ELSE判断用于处理这种情况。

```sql
CREATE OR REPLACE
FUNCTION FUNC_GETDEADLINE (INPUTDATE  DATE, DAY_OFFSET  NUMBER)
RETURN DATE
IS 
CURR_OFFSET NUMBER := 0;
IS_WORK_DAY NUMBER;
CURR_DATE DATE;
BEGIN
	IF(INPUTDATE = NULL) 
	THEN RETURN NULL;
	ELSE CURR_DATE := INPUTDATE;
	END IF;
	
	IF DAY_OFFSET = 0
	THEN
		RETURN TO_DATE(TO_CHAR(INPUTDATE,'YYYY-MM-DD'),'YYYY-MM-DD');
	END IF;
	
	IF DAY_OFFSET > 0
	THEN
		WHILE CURR_OFFSET < DAY_OFFSET LOOP
			CURR_DATE:=CURR_DATE + 1;
			
			SELECT COUNT(0) INTO IS_WORK_DAY FROM
			(
				SELECT CURR_DATE DAY_ID FROM DUAL
			)
			WHERE TO_CHAR ( DAY_ID, 'D' ) NOT IN ( 1, 7 ) 
			AND DAY_ID NOT IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 0 ) 
			OR DAY_ID IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 1 );
			
			IF(IS_WORK_DAY = 1)
			THEN 
				CURR_OFFSET := CURR_OFFSET + 1;
			END IF;
		END LOOP;
	ELSE 
		WHILE CURR_OFFSET > DAY_OFFSET LOOP
			CURR_DATE := CURR_DATE - 1;
			SELECT COUNT(0) INTO IS_WORK_DAY FROM
			(
				SELECT CURR_DATE DAY_ID FROM DUAL
			)
			WHERE TO_CHAR ( DAY_ID, 'D' ) NOT IN ( 1, 7 ) 
			AND DAY_ID NOT IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 0 ) 
			OR DAY_ID IN ( SELECT DM FROM T_CONF_CALENDAR WHERE SFJJR = 1 );
			
			IF(IS_WORK_DAY = 1)
			THEN 
				CURR_OFFSET := CURR_OFFSET - 1;
			END IF;
		END LOOP;
	END IF;
		
	RETURN TO_DATE(TO_CHAR(CURR_DATE,'YYYY-MM-DD'),'YYYY-MM-DD');
END FUNC_GETDEADLINE;
```

第一次写博客，有一些表述不太到位的地方，欢迎留言交流！
